<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API on Funky Si's Blog</title><link>https://www.funkysi1701.com/tags/api/</link><description>Recent content in API on Funky Si's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sun, 07 Mar 2021 20:00:45 +0000</lastBuildDate><atom:link href="https://www.funkysi1701.com/tags/api/index.xml" rel="self" type="application/rss+xml"/><item><title>Charting my Energy usage with the Octopus Energy API</title><link>https://www.funkysi1701.com/posts/2021/charting-my-energy-usage-with-the-octopus-energy-api/</link><pubDate>Sun, 07 Mar 2021 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2021/charting-my-energy-usage-with-the-octopus-energy-api/</guid><description>&lt;p>&lt;img class="img-fluid" alt="image" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/63ep8hp6ipyn2l4emiop.png" loading="lazy"
/>
&lt;/p>
&lt;p>Back when I was a kid, I used to record our weekly gas and electricity meter readings in a little notebook. We then typed these reading into a spreadsheet (this was in the pre-Excel days), which allowed plotting as a line graph.&lt;/p>
&lt;h2 id="how-would-i-go-about-doing-a-similar-thing-today">How would I go about doing a similar thing today?&lt;a class="anchor ms-1" href="#how-would-i-go-about-doing-a-similar-thing-today">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h2>
&lt;p>First off, I have a smart meter that submits meter readings every 30 minutes or so. However, I do not know anyway to get access to these readings directly, short of manually recording them like I did 30 years ago!&lt;/p>
&lt;p>Octopus Energy have a public API which allows you to pull your consumption readings. The smart meter sends your usage to your energy supplier, in my case Octopus, they then process these readings and allow them to be queried with an API they have created. It is not a direct connection to your data, but it is the next best thing.&lt;/p>
&lt;p>Other energy suppliers will hopefully follow this example and allow users access to their consumption data.&lt;/p>
&lt;h2 id="how-do-i-use-the-api">How do I use the API?&lt;a class="anchor ms-1" href="#how-do-i-use-the-api">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h2>
&lt;p>Using the API is straight forward. Octopus supply you with a secret which you use to authenticate against the API with Basic Auth, no password just a username. Then you just need to pass some details of your meters to get an object containing the last few days meter readings.&lt;/p>
&lt;p>&lt;a href="https://developer.octopus.energy/docs/api/" target="_blank" rel="noopener noreferrer">API Docs&lt;/a>
&lt;/p>
&lt;ul>
&lt;li>GET /v1/electricity-meter-points/{mpan}/meters/{serial_number}/consumption/&lt;/li>
&lt;li>GET /v1/gas-meter-points/{mprn}/meters/{serial_number}/consumption/&lt;/li>
&lt;/ul>
&lt;p>{mpan}/{mprn} of your gas or electricity meter, and {serial_number} is the serial number of the meters.&lt;/p>
&lt;p>Something to be aware of, I initially collected the last days consumption, which worked, however on one day I encountered a gap in the data for electricity. So, I changed to collect and store the last month&amp;rsquo;s data. I can then query this for what I need.&lt;/p>
&lt;p>Usually, the last 24 hours of data is available after midnight of that day. e.g. at midnight 2nd March all the data for 1st March should be available. This is not guaranteed so don&amp;rsquo;t rely on it, however I see no problem with having a few days delay between charting your usage.&lt;/p>
&lt;p>I am still testing this out but so far, I have three charts for gas (and the same for electricity), the first chart covers a 24-hour period, the next covers a day total over 2 weeks, the final chart covers a total for each month (as I write this I have less than a month&amp;rsquo;s worth of data!)&lt;/p>
&lt;p>For the day and 2 weeks charts, I plot a comparison line of the previous period so you can easily compare the current and previous usage. From my limited testing I have already discovered my usage is very similar day to day.&lt;/p>
&lt;p>Another point of interest is that gas consumption is in m^3 and electricity is in kW/h.
&lt;img class="img-fluid" alt="image" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r5d35ceh0q5zgc15vos8.png" loading="lazy"
/>
&lt;/p>
&lt;p>If you are interested in trying the Octopus Energy API, here is a referral &lt;a href="https://share.octopus.energy/amber-eel-810" target="_blank" rel="noopener noreferrer">link&lt;/a>
.&lt;/p></description></item><item><title>Gated Release</title><link>https://www.funkysi1701.com/posts/2019/gated-release/</link><pubDate>Fri, 05 Apr 2019 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2019/gated-release/</guid><description>&lt;p>Automated releases of software are great but how can we add an element of feedback so only good releases go live.&lt;/p>
&lt;p>I have been using Azure DevOps to release my &lt;a href="https://www.funkysi1701.com/pwned-pass/">PwnedPass&lt;/a>
android app to the Google Play Store for a while now. There are options to deploy to the alpha, Beta or Production tracks and even to set % of users to target. For the full range of options check out the Google Play &lt;a href="https://marketplace.visualstudio.com/items?itemName=ms-vsclient.google-play" target="_blank" rel="noopener noreferrer">extension&lt;/a>
for Azure DevOps.&lt;/p>
&lt;p>My release starts by publishing to 10% of users on the production track, my next step makes use of the increase rollout option to increase this %, you can have as many of these additional steps as you want until you reach 100% of your users.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/04/image.png?fit=662%2C116&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Now if you run this release now it will just run through each of the steps one after the other. Now of course you can add a pre or post approval to your pipeline but this just adds a manual dependency to your release. Whoever does the approving needs to check things are working before approving or worse just approves regardless.&lt;/p>
&lt;p>Azure DevOps has the concept of &lt;a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/release/deploy-using-approvals?view=azure-devops" target="_blank" rel="noopener noreferrer">gated releases&lt;/a>
which allows you to add automated checks before or after a release happens. These automated checks can be any of the following:&lt;/p>
&lt;ul>
&lt;li>An Azure Function&lt;/li>
&lt;li>A Rest API call&lt;/li>
&lt;li>Azure Monitor Alert&lt;/li>
&lt;li>Query Work Items&lt;/li>
&lt;li>Security and Compliance Assessment&lt;/li>
&lt;/ul>
&lt;p>We are going to make use of the Azure Monitor Alert, to create an alert from your Application Insights data and only continue the rollout if no failures are detected.&lt;/p>
&lt;p>Open up your application insights resource in the Azure portal and look in alerts. Click add new alert rule.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/04/image-1.png?fit=662%2C552&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Select your application insights resource in Resource, In Condition choose a condition to check, I chose Failed Requests, so every time a failure is registered in my API I can stop the deployment. The exact criteria you want to use is entirely up to you.&lt;/p>
&lt;p>Create an action group, I just set my alert to send an email to myself but there are other alert actions you may want to try. Give your alert a name and description and click save.&lt;/p>
&lt;p>Now all we need to do is make Azure DevOps make use of this alert. In your release pipeline select the pre-deployment conditions of your second step and open up the Gates section.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/04/image-2.png?fit=662%2C498&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Choose a suitable time to evaluate, I have been using something long like 12 or 24 hours so if there are problems there is time for it to be noticed. Choose Version 1 of the task (I was not able to get it to work with Version 0)&lt;/p>
&lt;p>Now select your Azure subscription and Resource Group and leave the rest of the settings as they are. Now your Deployment will stop and analyse application insights for any Failed requests and will halt if it finds any.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/04/image-3.png?fit=662%2C88&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>I am still testing this out but it will take a few days to figure out if this what I want due to the large time scales involved. I feel this is going to be an improvement of manually approving release steps.&lt;/p></description></item><item><title>Documenting your API</title><link>https://www.funkysi1701.com/posts/2019/documenting-your-api/</link><pubDate>Wed, 27 Mar 2019 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2019/documenting-your-api/</guid><description>&lt;p>So you have created a super API that does something amazing. How do you document it so people will use it?&lt;/p>
&lt;p>One way of easily documenting your API is to install the Swashbuckle package.&lt;/p>
&lt;pre tabindex="0">&lt;code>Install-Package Swashbuckle.AspNetCore
Install-Package Swashbuckle.AspNetCore.Swagger
&lt;/code>&lt;/pre>&lt;p>Then in you startup.cs add the following lines&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//In ConfigureServices&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>services.AddSwaggerGen(c =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.SwaggerDoc(&lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">new&lt;/span> Info { Title = &lt;span style="color:#e6db74">&amp;#34;API&amp;#34;&lt;/span>, Version = &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>, Description = &lt;span style="color:#e6db74">&amp;#34;An API Description&amp;#34;&lt;/span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.IncludeXmlComments(&lt;span style="color:#66d9ef">string&lt;/span>.Format(&lt;span style="color:#e6db74">@&amp;#34;{0}\API.xml&amp;#34;&lt;/span>, System.AppDomain.CurrentDomain.BaseDirectory));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//In Configure&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.UseSwagger();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>app.UseSwaggerUI(c =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.SwaggerEndpoint(&lt;span style="color:#e6db74">&amp;#34;/swagger/v1/swagger.json&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;API V1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.RoutePrefix = &lt;span style="color:#66d9ef">string&lt;/span>.Empty;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now when you browse to your API you will see the swagger documentation system.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/03/image-3.png?w=662&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>The RoutePrefix setting controls the path in which swagger will display. I have my docs at the root, but you might want them under the /docs or similar path.&lt;/p>
&lt;p>The IncludeXmlComments setting from the ConfigureServices method allows you to load in any XML comments you have added to methods. For this to work you need to enable a setting to your build.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/03/image-4.png?w=662&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>The XML documentation file must be ticked and contain a path. Everytime you do a build, a XML file will be generated which contains all the comment blocks you have added to your code.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/03/image-5.png?w=662&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Swagger will then use this XML documentation file to produce lovely looking documentation without you having to do anything extra.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="Image" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2019/03/image-6.png?fit=662%2C260&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p></description></item></channel></rss>