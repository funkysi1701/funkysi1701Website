<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Funky Si's Blog</title><link>https://www.funkysi1701.com/tags/git/</link><description>Recent content in Git on Funky Si's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 25 Jul 2022 18:00:45 +0000</lastBuildDate><atom:link href="https://www.funkysi1701.com/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>A brief history of Source Control</title><link>https://www.funkysi1701.com/posts/2022/a-brief-history-of-source-control/</link><pubDate>Mon, 25 Jul 2022 18:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2022/a-brief-history-of-source-control/</guid><description>&lt;p>I have been thinking back to when I started using source control and some of the different tools I have used over the years.&lt;/p>
&lt;p>When I was learning to code it was some time after I had learned the basics that I learnt about source control. Back when I started writing webpages I would have a folder containing all my html, css, images etc and I would FTP these up to my web server. If I made a change to a file I would reupload the file I changed, or reupload all my files to make sure I didn&amp;rsquo;t miss anything.&lt;/p>
&lt;p>It was sometime later that I learnt about source control. I can&amp;rsquo;t remember exactly when, but I suspect it was after I had used it at work. (between 2006 and 2010 as a best guess, my oldest repo says it is 12 years old!)&lt;/p>
&lt;p>Source control (or version control) is the practice of tracking and managing changes to code. These tools provide a running history of code development and help to resolve conflicts when merging.&lt;/p>
&lt;img src="https://www.funkysi1701.com/images/svn.jpg" width="400px" align="left" />
&lt;p>The first source control tool I remember using was subversion. The windows client for this was called &lt;a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener noreferrer">TortoiseSVN&lt;/a>
and is still available today. I know this as my current job has some legacy code which still uses it.&lt;/p>
&lt;p>Back then, to use Subversion you needed to set up a linux server with subversion on it, and you would then connect over your LAN to it from your development machine. This was before the days of github, where everything was hosted on a SaaS service somewhere. I do not remember the process of getting everything setup, but with it being linux, there was no doubt a load of config files to edit, and different dependencies to install.&lt;/p>
&lt;p>Over the years I installed various web interfaces to allow &amp;ldquo;&lt;em>browsing&lt;/em>&amp;rdquo; of source code, some even had bug trackers built in. The ones I can remember are &lt;a href="https://trac.edgewall.org/" target="_blank" rel="noopener noreferrer">Trac&lt;/a>
and &lt;a href="https://www.redmine.org/" target="_blank" rel="noopener noreferrer">Redmine&lt;/a>
. Both look to still be available and you can probably install them if you want to remember way back when.&lt;/p>
&lt;img src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/03/github-octocat.png?resize=300%2C158&amp;ssl=1" width="400px" align="right" />
&lt;p>The first hosted source control tool I remember using was &lt;a href="https://bitbucket.org/product/" target="_blank" rel="noopener noreferrer">bitbucket&lt;/a>
and this as far as I can tell has only ever supported git. So I am guessing I imported my subversion repos into git ones at this point. The reason for bitbucket was chosen was it allowed private repositories for free, at that point github was probably available but only provided public repositories.&lt;/p>
&lt;p>After bitbucket the git repos where moved to Azure DevOps or Visual Studio Team Services as it was called back then. This move was mainly to take advantage of the builds and releases feature and to decommission some aging build servers.&lt;/p>
&lt;img src="https://www.funkysi1701.com/images/azuredevops.png" align="left" width="400px" />
&lt;p>This brings me to today where I have a mix of public repos on github and private repos on Azure DevOps. For building my code I use a mix of github actions and Azure Pipelines. As Microsoft own both services now, there is a fair amount of crossover between the two services, however it is far from certain which service is the future.&lt;/p>
&lt;p>Wow, my code has moved around a lot over the years. From no source control, to subversion, to git, to Bitbucket to Azure DevOps!&lt;/p></description></item><item><title>Code Reviews</title><link>https://www.funkysi1701.com/posts/2018/codereviews/</link><pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2018/codereviews/</guid><description>&lt;p>Reviewing code is a great habit to get into. Code reviews help share knowledge between your team members and help catch bugs before they get into production. But how do you get into the habit of reviewing and avoid the we don’t have time to do this mentality?&lt;/p>
&lt;p>Visual Studio Team Services (VSTS) has some great options that can help make code reviews second nature.&lt;/p>
&lt;h4 id="pull-requests">Pull Requests&lt;a class="anchor ms-1" href="#pull-requests">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h4>
&lt;p>A lot of source control systems have the concept of pull requests. This is where you request others to review your code usually in a branch and if they approve it, merge it into a main branch.&lt;/p>
&lt;p>To create a pull request in VSTS go to the Code section and select Pull Requests. Often VSTS will make a suggestion of what branch to make a pull request for, if you don’t see this just click the New Pull request button.&lt;/p>
&lt;p>Select a branch you want to merge from and a branch that should be merged into (usually you merge into master from a feature branch). Give your pull request a title and description and select who should review your code, this can either be an individual or a group of people. You can also review all the changes that will be reviewed so you can make any last minute changes before it is reviewed.&lt;/p>
&lt;p>Now if you are anything like me you want your code merged in as soon as you have created your pull request and there is nothing stopping you reviewing your own code and clicking approve and merge on your own pull request. However &lt;a href="https://docs.microsoft.com/en-us/vsts/git/branch-policies?view=vsts" target="_blank" rel="noopener noreferrer">branch policies&lt;/a>
is a way around this problem.&lt;/p>
&lt;h4 id="branch-policies">Branch Policies&lt;a class="anchor ms-1" href="#branch-policies">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h4>
&lt;p>&lt;img class="img-fluid" alt="Branch Policy" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2018/04/save-policy-changes.png?resize=599%2C901&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Branch policies allow you to specify how your code gets merged in.&lt;/p>
&lt;p>Go to the list of branches in VSTS and select branch policy and you will see a whole host of options to customise the merge process. If you do this on the master branch you will not be able to commit any changes to master without it going through a pull request.&lt;/p>
&lt;p>The first option enables you to select how many reviewers are needed on your code. If no one else works on your project best not setting this, but for everyone else setting at least one person to review your code is a great practice.&lt;/p>
&lt;p>Next you can ensure that your pull request is linked to a work item, this helps keep ensure you are actually fixing issues and not just making change for the sake of it.&lt;/p>
&lt;p>Check for comment resolution is a good setting to enable. This ensures that if your reviewer has commented about you needing to change this line here, it ensures that you do.&lt;/p>
&lt;p>Enforce merge strategy allows you to choose between fast forward merge or squash merge.&lt;/p>
&lt;p>Build validation enables the code to be built using a build definition you have configured. This is a great way to check code builds or tests pass before it gets merged in.&lt;/p>
&lt;p>The last two options allow you to specify code reviewers and third party external services.&lt;/p></description></item><item><title>How to get Zero Code Changes outside of Source Control</title><link>https://www.funkysi1701.com/posts/2017/get-zero-code-changes-outside-source-control/</link><pubDate>Mon, 13 Nov 2017 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2017/get-zero-code-changes-outside-source-control/</guid><description>&lt;p>Source control is bread and butter for web developers, however not so much for SQL developers and other business people. One of my goals for the coming year is to get the whole of my team using source control processes.&lt;/p>
&lt;p>One of the arguments against using source control is there will always be a few exceptions where it won’t be used. Lets look at a few scenarios to help make the case for source control.&lt;/p>
&lt;p>&lt;strong>Scenario One&lt;/strong>&lt;/p>
&lt;p>Web Dev 1 makes a change in production to fix an issue and doesn’t use source control. Web Dev 2 is working on a new feature and makes use of source control. He is given the sign-off to deploy his new feature and in the process undoes Web Dev 1’s fix.&lt;/p>
&lt;p>Management blames Web Dev 2 as they “broke” stuff during the deployment. Web Dev 2 doesn’t understand what happened and Web Dev 1 is oblivious to the entire scenario despite in reality being part of the problem.&lt;/p>
&lt;p>&lt;strong>Scenario Two&lt;/strong>&lt;/p>
&lt;p>A SQL Dev works all night to fix a problem. He deploy to production and doesn’t notice a missed where clause due to lack of sleep.&lt;/p>
&lt;p>—&lt;/p>
&lt;p>Let’s look at these two scenarios done with the whole team buying into source control.&lt;/p>
&lt;p>&lt;strong>Scenario One&lt;/strong>&lt;/p>
&lt;p>Web Dev 1 makes a change in production to fix an issue and also commits to source control. This takes him an extra 5 minutes (if that!) Web Dev 2 is working on a new feature and makes use of source control. He is given the sign-off to deploy his new feature and in the process merges Web Dev 1’s fix before he deploys to production.&lt;/p>
&lt;p>Management is happy with Web Dev 1, nothing is broken and new functionality has made the website better not worse.&lt;/p>
&lt;p>&lt;strong>Scenario Two&lt;/strong>&lt;/p>
&lt;p>A SQL Dev works all night to fix a problem. He deploy to production and doesn’t notice a missed where clause due to lack of sleep, he also commits to source control this takes him an extra 5 minutes (if that!).&lt;/p>
&lt;p>In the morning a colleague looks through the commits made during the night and queries the missing where clause. A fix is made in source control and deployed, management and the client are unaware that a problem was created and fixed.&lt;/p>
&lt;p>—&lt;/p>
&lt;p>These are simple scenarios but I cannot think of any situation where the outcome would be better to not use source control. These examples assume no continuous deployment, adding this to the system before every team has bought into source control would cause bugs and issues all over the place.&lt;/p>
&lt;p>However with a team that is 100% behind source control continuous deployment can achieve an amazing productivity boost. After every commit code could be automatically tested, reviewed by other members of the team and deployed to test environments for further analysis. Only tested code that has been reviewed can get anywhere near production environments.&lt;/p>
&lt;p>Having said all this there are ways especially on the SQL side to mitigate loosing changes while you work on training individuals and convincing management. Before any code is deployed to production do a schema compare. If you only see changes you have made you can proceed, if you don’t shout at your team.&lt;/p>
&lt;p>&lt;strong>Advantages&lt;/strong>&lt;/p>
&lt;p>Code Reviews&lt;br>
Team awareness of what is being changed&lt;br>
History of changes&lt;br>
Smoother Deployments&lt;br>
Automation&lt;br>
Better Teamwork&lt;br>
Diff changes between different versions&lt;br>
Many more&lt;/p>
&lt;p>&lt;strong>Disadvantages&lt;/strong>&lt;/p>
&lt;p>Time to learn tools&lt;br>
Remember to commit changes&lt;br>
Technologies that use binary files harder to version control&lt;/p></description></item><item><title>GitHub history</title><link>https://www.funkysi1701.com/posts/2017/github-history/</link><pubDate>Mon, 24 Apr 2017 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2017/github-history/</guid><description>&lt;p>I created my GitHub account in August 2010, lets look at what I have done with it.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/04/git10.jpg?resize=768%2C173&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>In 2010 I started by committing the code for an old php website I had created. Then in December I committed some other php sites.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/04/git11.jpg?resize=768%2C171&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Between 12 December 2010 and 29 September 2011 I must have created some automated process which is why there is a commit every day. Looking at the diff it appears to be related to tracking visitors to a site. I assume back then I hadn’t heard of the .gitignore file!&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/04/git14.jpg?resize=768%2C174&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Nothing for a few years until 2014, when I started compiling a code samples collection, this is bits of code that I want to show off, I have added to this since 2015 so I really should go back to this as my skills have developed a bit since then.&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/04/git15.jpg?resize=768%2C173&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>In 2015 I really started to think of myself as a developer, I added repositories for Raspberry Pi, and a few C# ideas I had. I ended the year taking part in Advent of Code&lt;/p>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/04/git16.jpg?resize=768%2C173&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>What did I do last year? Well I started going to York Code Dojo and this meant lots of forks from their code examples and also my first pull request. I also did a fair bit of looking at other repositories trying to find a good open source project to contribute to, still not found one for me yet. Lastly I ended 2016 with a bit of Advent of Code.&lt;/p>
&lt;p>Not sure how enthralling a blog post this is, but fascinating to see the different commit histories.&lt;/p></description></item><item><title>Github Vs Bitbucket Vs Visual Studio Team Services</title><link>https://www.funkysi1701.com/posts/2017/github-vs-bitbucket-vs-vsts/</link><pubDate>Mon, 06 Mar 2017 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2017/github-vs-bitbucket-vs-vsts/</guid><description>&lt;p>As a developer using source control and git is bread and butter of what we do. Github is probably the most popular and widely known hosting service for source control but I have also used Bitbucket and Visual Studio Team Services. Lets have a look at each one and what they offer. Note while I have included prices I have only tried out the free versions.&lt;/p>
&lt;h3 id="github">Github&lt;a class="anchor ms-1" href="#github">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/03/github-octocat.png?resize=300%2C158&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;ul>
&lt;li>URL: &lt;a href="https://github.com/" target="_blank" rel="noopener noreferrer">https://github.com/&lt;/a>
&lt;/li>
&lt;li>Private Repositories: Not Available for free&lt;/li>
&lt;li>Public Repositories: Unlimited&lt;/li>
&lt;li>Team Size: Unlimited&lt;/li>
&lt;li>Prices: $7 per month for unlimited private repositories, $25 per month for 5 users then $9 per month per user&lt;/li>
&lt;/ul>
&lt;p>This is probably the most widely used service for hosting code. Over 13 million repositories of code. This is an ideal solution if you want your code to be publicly viewable, but take care not to publish passwords, private keys or your companies trade secrets. Every developer should have a Github account for displaying bits of code they are proud of.&lt;/p>
&lt;p>There are a number of externally built APIs that link into Github for doing extra features, like building, code coverage etc&lt;/p>
&lt;h3 id="bitbucket">Bitbucket&lt;a class="anchor ms-1" href="#bitbucket">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2017/03/d8TRzzL.png?resize=150%2C150&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;ul>
&lt;li>URL: &lt;a href="https://bitbucket.org/" target="_blank" rel="noopener noreferrer">https://bitbucket.org/&lt;/a>
&lt;/li>
&lt;li>Private Repositories: Unlimited&lt;/li>
&lt;li>Public Repositories: Unlimited&lt;/li>
&lt;li>Team Size: Less than 5&lt;/li>
&lt;li>Prices: $10 per month for 10 Users, $100 per month for 100 Users, $200 per month for Unlimited Users&lt;/li>
&lt;/ul>
&lt;p>At my last job we used Bitbucket extensively for all our projects. All the code was private so only the team could access it, however before I left we were approaching the 5 user limit (but looking at these prices cost seems very reasonable)&lt;/p>
&lt;h3 id="visual-studio-team-services">Visual Studio Team Services&lt;a class="anchor ms-1" href="#visual-studio-team-services">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2016/11/Visual-Studio-Team-Services.png?resize=300%2C136&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;ul>
&lt;li>URL: &lt;a href="https://www.visualstudio.com/team-services/" target="_blank" rel="noopener noreferrer">https://www.visualstudio.com/team-services/&lt;/a>
&lt;/li>
&lt;li>Private Repositories: Unlimited&lt;/li>
&lt;li>Public Repositories: Not Available&lt;/li>
&lt;li>Team Size: Less than 5&lt;/li>
&lt;li>Prices: $30 per month for 10 users, and other features paid for via Azure Invoices&lt;/li>
&lt;/ul>
&lt;p>Visual Studio Team Services or VSTS is Microsoft’s version control solution and I have only just started using it, however what I have seen I like. There are lots of options for building your code so VSTS is more than just hosting your code it is verging on a Continuous Integration/Delivery solution. Being a Microsoft product there are numerous links to Azure and it is easy to deploy stuff to that platform.&lt;/p>
&lt;p>All three have options for tracking issues but VSTS have options to add Stakeholder users which would allow none developers to add and keep track of issues and progress with them.&lt;/p>
&lt;p>If I want to run tests, look at code coverage VSTS is probably the solution I would go for, if I want something that is public I would go for Github. What do you think which of these is your favourite?&lt;/p></description></item><item><title>What should be in Source Control?</title><link>https://www.funkysi1701.com/posts/2016/what-should-be-in-source-control/</link><pubDate>Thu, 24 Nov 2016 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2016/what-should-be-in-source-control/</guid><description>&lt;p>I am currently working on source code that is over 5Gb in size. This is mostly due to a poorly thought out folder structure, there are code files, images and Excel files all jumbled together. I think a clear distinction should be made between source code and data.&lt;/p>
&lt;h3 id="source-code">Source Code&lt;a class="anchor ms-1" href="#source-code">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>I will define source code as anything that is written in order to compile and run the project. If it is a webpage it will be all the HTML, CSS and Javascript or any file used to produce these. I would also include any configuration files and files used to build/deploy the website or project. Anything that is compiled from your source files can safely be ignored.&lt;/p>
&lt;h3 id="data">Data&lt;a class="anchor ms-1" href="#data">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>I would define data as anything that is added to the project during its life. So if you have an upload option, anything that is uploaded I would describe as data. The site should still function without (or very little) data.&lt;/p>
&lt;h3 id="images">Images&lt;a class="anchor ms-1" href="#images">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>Images can fit into both groups. Any icons or images attached to the functionality of the project I would class as source code. However anything that is uploaded should be classed as Data.&lt;/p>
&lt;h3 id="databases">Databases&lt;a class="anchor ms-1" href="#databases">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>The database should also be classed as both. The data, anything that is inside a database table should normally be classed as data. Stored Procedures, Functions and Views are all Source Code and would benefit from version control.&lt;/p>
&lt;h3 id="source-control--backup">Source Control != Backup&lt;a class="anchor ms-1" href="#source-control--backup">&lt;i class="fas fa-link">&lt;/i>&lt;/a>&lt;/h3>
&lt;p>Source control is not an excuse not to backup things. Don’t just commit files to source control so you know you can restore them if you need to. Files in general in source control are there so you can see how they changed over time as the code base changed. Files in you backup are a snapshot of what the application was at a point in time and will include ALL the data.&lt;/p>
&lt;p>One last point before I end. If you are hosting on a Cloud Computing platform like Azure it gives you an easy way to distinguish between Data and Code.&lt;/p>
&lt;p>Anything in your&lt;/p>
&lt;ul>
&lt;li>Web App = Code&lt;/li>
&lt;li>Blob Storage = Data&lt;/li>
&lt;li>SQL = Data/Code&lt;/li>
&lt;/ul>
&lt;p>Each project is unique and there will always be exceptions to these suggestions but I think this is a good goal to have. What do you think?&lt;/p></description></item><item><title>Automatic Git Tagging</title><link>https://www.funkysi1701.com/posts/2016/automatic-git-tagging/</link><pubDate>Thu, 16 Jun 2016 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2016/automatic-git-tagging/</guid><description>&lt;p>One of the features of git is the ability to tag a point in my change history with a tag. For a while now I have been manually tagging my code whenever I do a release, so I can easily work out what has changed by doing a diff between two tags.&lt;/p>
&lt;p>Now that I am automating my release process with TeamCity I am thinking about how to manage my tags better.&lt;/p>
&lt;p>TeamCity has a setting called VCS Labeling which comes in very handy.
&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2016/06/Untitled.jpg?w=1595&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>Configuring it is fairly simple as it only has three settings.&lt;/p>
&lt;p>&lt;strong>VCS root to label&lt;/strong>: This is obviously the url to your git repository
&lt;strong>Labeling pattern&lt;/strong>: This is the text of the label to be added.
&lt;strong>Label successful builds only&lt;/strong>: Do you really want to add a tag if the build failed?&lt;/p>
&lt;p>A tag needs to have a unique name, so adding a tag just called &lt;strong>deployed&lt;/strong> won’t work. When I used to add tags manually I used the naming convention of &lt;strong>deployedyyyymmdd&lt;/strong>. While this naming convention is possible with TeamCity I use something a bit more complex to provide more information about what has been deployed.&lt;/p>
&lt;p>TeamCity provides lots of parameters that can be used in your build steps and also in the Labeling pattern box. I started off using &lt;strong>deployed-build-%system.build.number%&lt;/strong> as my tag which just marks git with the TeamCity build number.&lt;/p>
&lt;p>When I run a TeamCity deployment I don’t always use the same configuration options, I deploy locally, to a test server or to production and sometimes I just deploy the frontend or the backend. How cool would it be to include this information in the tag text?&lt;/p>
&lt;p>Well the next step was to change my Labeling pattern to &lt;strong>deployed-build-%system.build.number%-%ServerName%-%DatabaseName%-%FrontEndPath%&lt;/strong>, this adds the backend database config settings and the path the frontend was deployed to. Now when looking at git you can see commits marked with multiple tags, one for each deployment that succeeded and the tag will indicate the settings used during that deployment.&lt;/p>
&lt;p>Now I will never forget to add the tag after a release as the adding of a tag is part of the deployment process, if the deployment fails the tag won’t be added. I can test my deployment to test and git will show if this has been successful, and when I deploy live this will also show up.&lt;/p>
&lt;p>How do you use tags? Do you mark successful builds with a tag? Why not let me know or leave a comment below.&lt;/p></description></item><item><title>My git repository is too large!</title><link>https://www.funkysi1701.com/posts/2016/my-git-repository-is-too-large/</link><pubDate>Thu, 11 Feb 2016 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2016/my-git-repository-is-too-large/</guid><description>&lt;p>Today I did a clone of one of my git repositories and it took ages to download. Looking into what got downloaded it was easy to see why. The .git folder was over 500Mb in size.&lt;/p>
&lt;p>I know how this has happened. This repository was created in 2013 and has been used by me as a dumping ground for lots of things related to the code which never should have been committed.&lt;/p>
&lt;p>Since 2013 I have learnt a lot more about coding and git so the current version of the files in git isn’t too bad. But git keeps the history of changes for every file so bad practices like this are kept.&lt;/p>
&lt;p>What can I do about this? Well what does google suggest? I found this &lt;a href="http://stevelorek.com/how-to-shrink-a-git-repository.html" target="_blank" rel="noopener noreferrer">blog post&lt;/a>
.&lt;/p>
&lt;p>It suggests ways of listing all the large files that are stored in git and a way to remove them. As I am the only person that regularly commits to this repository I see no problem with giving it a go.&lt;/p>
&lt;p>I will summarise the steps here.&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone url
&lt;/code>&lt;/pre>&lt;p>Now you need all the remote branches so there is a bash script to run&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
for branch in `git branch -a | grep remotes | grep -v HEAD | grep -v master`; do
git branch –track ${branch##*/} $branch
done
&lt;/code>&lt;/pre>&lt;p>Another bash script then lists the top 10 large files&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
#set -x
# Shows you the largest objects in your repo’s pack file.
# Written for osx.
#
# @see http://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/
# @author Antony Stubbs
# set the internal field spereator to line break, so that we can iterate easily over the verify-pack output
IFS=$’\n’;
# list all objects including their size, sort by size, take top 10
objects=`git verify-pack -v .git/objects/pack/pack-*.idx | grep -v chain | sort -k3nr | head`
echo “All sizes are in kB. The pack column is the size of the object, compressed, inside the pack file.”
output=“size,pack,SHA,location”
for y in $objects do
# extract the size in bytes
size=$((`echo $y | cut -f 5 -d ‘ ‘`/1024))
# extract the compressed size in bytes
compressedSize=$((`echo $y | cut -f 6 -d ‘ ‘`/1024))
# extract the SHA
sha=`echo $y | cut -f 1 -d ‘ ‘`
# find the objects location in the repository tree
other=`git rev-list –all –objects | grep $sha`
#lineBreak=`echo -e “\n”`
output=“${output}\n${size},${compressedSize},${other}”
done
echo -e $output
&lt;/code>&lt;/pre>&lt;p>After running the script you will see details of your largest files. I had *.msi and *.exe files in the mix. To remove them run the following, where filename is the path to the file that needs removing.&lt;/p>
&lt;pre tabindex="0">&lt;code>git filter-branch –tag-name-filter cat –index-filter ‘git rm -r –cached –ignore-unmatch filename’ –prune-empty -f — –all
&lt;/code>&lt;/pre>&lt;p>To reclaim the disk space run the following commands&lt;/p>
&lt;pre tabindex="0">&lt;code>rm -rf .git/refs/original/
git reflog expire –expire=now –all
git gc –prune=now
git gc –aggressive –prune=now
&lt;/code>&lt;/pre>&lt;p>Now push your changes back to the remote server.&lt;/p>
&lt;pre tabindex="0">&lt;code>git push origin –force –all
git push origin –force –tags
&lt;/code>&lt;/pre>&lt;p>Now if you do a clone it will be much smaller than before and you can get back to coding much quicker, without having to wait.&lt;/p></description></item><item><title>Common git commands</title><link>https://www.funkysi1701.com/posts/2015/common-git-commands/</link><pubDate>Thu, 06 Aug 2015 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2015/common-git-commands/</guid><description>&lt;p>I use git as my source control system. Here are some of the most common git commands in no particular order.&lt;/p>
&lt;ul>
&lt;li>Check Out a git Repository &lt;strong>git clone /path/to/repository&lt;/strong>&lt;/li>
&lt;li>Add files to commit &lt;strong>git add &lt;filename>&lt;/strong>&lt;/li>
&lt;li>Commit files to &lt;strong>git git commit -m “Commit message”&lt;/strong>&lt;/li>
&lt;li>Push changes to server &lt;strong>git push origin master&lt;/strong>&lt;/li>
&lt;li>Show status &lt;strong>git status&lt;/strong>&lt;/li>
&lt;li>Create new branch &lt;strong>git checkout -b &lt;branchname>&lt;/strong>&lt;/li>
&lt;li>Switch to a branch &lt;strong>git checkout &lt;branchname>&lt;/strong>&lt;/li>
&lt;li>Get remote changes &lt;strong>git pull&lt;/strong>&lt;/li>
&lt;li>Merge a different branch into the current one &lt;strong>git merge &lt;branchname>&lt;/strong>&lt;/li>
&lt;li>View merge conflicts &lt;strong>git diff&lt;/strong>&lt;/li>
&lt;li>Temporarily stash uncommitted changes &lt;strong>git stash&lt;/strong>&lt;/li>
&lt;li>Undo a commit &lt;strong>git reset –hard &lt;commit>&lt;/strong>&lt;/li>
&lt;li>Show details about a commit &lt;strong>git show &lt;commit>&lt;/strong>&lt;/li>
&lt;li>Show version history of current branch &lt;strong>git log&lt;/strong>&lt;/li>
&lt;li>Gets all remote branches &lt;strong>git fetch origin&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Most of the time I use the &lt;a href="https://sourceforge.net/projects/gitextensions/" target="_blank" rel="noopener noreferrer">git extensions&lt;/a>
tools to do my git work, but there are times when only the command line will do.&lt;/p></description></item><item><title>Writing better Git commit messages</title><link>https://www.funkysi1701.com/posts/2015/writing-better-git-commit-messages/</link><pubDate>Sat, 25 Jul 2015 20:00:45 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2015/writing-better-git-commit-messages/</guid><description>&lt;p>&lt;img class="img-fluid" alt="" src="https://storageaccountblog9f5d.blob.core.windows.net/blazor/wp-content/uploads/2015/07/git_commit.png?w=439&amp;amp;ssl=1" loading="lazy"
/>
&lt;/p>
&lt;p>I always use source control for my coding changes, however some of my commit messages leave something to be desired.&lt;/p>
&lt;p>I always try to write a commit message but I often think that the change themselves should be enough to indicate what I did. I also don’t need to include who made the change or the time and date and that gets included automatically.&lt;/p>
&lt;p>Here are some tips I have found that may help me in the future.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Ask yourself why you are making this change. The Who, When and What are already being covered so it is only the why that needs including in the commit message.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If your commit breaks something or causes side affects or a new dependency this should be included in the commit message. If your commit breaks functionality, consider if you really need to commit it yet, maybe only commit once fixed?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If your commit includes a long list of changes consider if the commit needs splitting into several commits. It is easy to only commit one or two files write a specific commit message and then commit the rest of the changes separately.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Consider including a subject for larger commits. The following comes from the git manual.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>Though not required, it’s a good idea to begin the commit message with a single short
(less than 50 character) line summarizing the change, followed by a blank line and then
a more thorough description. The text up to the first blank line in a commit message
is treated as the commit title, and that title is used throughout Git.
&lt;/code>&lt;/pre>&lt;ol start="5">
&lt;li>If you use a subject follow the following conventions:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Limit of 50 characters&lt;/li>
&lt;li>Start with a capital letter&lt;/li>
&lt;li>Do not end with a full stop&lt;/li>
&lt;li>Use the imperative mood i.e. write as if issuing a command&lt;/li>
&lt;/ul></description></item><item><title>Source Control Fail</title><link>https://www.funkysi1701.com/posts/2015/source-control-fail/</link><pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate><guid>https://www.funkysi1701.com/posts/2015/source-control-fail/</guid><description>&lt;p>Every developer uses source control, it is a great tool for keeping track of changes to your code, seeing who has done what.&lt;/p>
&lt;p>However I keep messing up, my use of it. I am fairly disciplined when creating new features, all my changes will get committed to source control and when I am happy I will deploy these changes to the live system. But as soon as there is a bug, especially one where the client is chasing for a fix, I will deploy a fix as soon as humanly possible on to the live system.&lt;/p>
&lt;p>At first glance there is nothing wrong with what I have described but what happens the next time I deploy a new feature. Yes the bug the client was complaining about gets deployed with the new feature as the fix was never committed into source control. The client gets angry as the bug he was screaming about is back again.&lt;/p>
&lt;p>Every change you make to the system &lt;strong>MUST&lt;/strong> be committed to source control. If it isn’t that change will look like it never existed. I have worked with source control for over 5 years why do I keep making this rookie mistake over and over.&lt;/p>
&lt;p>Troy Hunt has a &lt;a href="http://www.troyhunt.com/2011/05/10-commandments-of-good-source-control.html" target="_blank" rel="noopener noreferrer">blog post&lt;/a>
about the 10 commandments of using source control. His number two commandment is “If it’s not in source control, it doesn’t exist” He talks more about code you have written being not saved into source control, but the principal is the same for my example as his.&lt;/p>
&lt;p>There are ways to automatically deploy from source control, however most of the time you don’t want your live database being rebuilt because you fixed a typo. Additional steps will need to be implemented and there is still the chance that you might want to bypass these steps to fix the urgent problem. The only way past this problem is for you and everyone on your team to be disciplined and only ever commit to source control first, and only after that deploy live (either automatically or manually)&lt;/p></description></item></channel></rss>